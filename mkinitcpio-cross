#! /usr/bin/env python3
"""
Arch Linux mkinitcpio command without using chroot to allow for cross-
installation of 64-bit OS from 32-bit-only environment.

Requirements:

bash: parse mkinitcpio preset file
"""

import sys
from os import (
    access, X_OK,
    execv, pathsep, getcwd, environ,
)
import os
import subprocess
import struct
from os.path import isabs
from linux_modules import depmod

def main(basedir, preset, *args, skip_depmod=False):
    get_mkinitcpio()
    
    # The "depmod" files installed with the Linux package a refer to module
    # file names ending with ".ko", but the actual file names end with
    # ".ko.gz"
    if not skip_depmod:
        depmod(basedir, preset_kver(basedir, preset))
    
    # The "mkinitcpio" script tries to run ". functions", so get it to run
    # our "functions" script first via the search path.
    PATH = "PATH"
    path = getcwd()
    try:
        path = pathsep.join((path, environ[PATH]))
    except LookupError:
        pass
    environ[PATH] = path
    
    environ["BASEDIR"] = basedir
    
    args = (MKINITCPIO, "-p", preset) + args
    print(*args, file=sys.stderr)
    sys.stderr.flush()
    execv(args[0], args)

def get_mkinitcpio():
    if access(MKINITCPIO, X_OK):
        return
    
    from shutil import copyfileobj
    from os import (fstat, fchmod)
    from stat import (S_IXUSR, S_IXGRP, S_IXOTH)
    from contextlib import closing
    
    try:
        from urllib.request import (urlopen, Request)
    except ImportError:
        from urllib2 import (urlopen, Request)
    
    url = "https://projects.archlinux.org/{0}.git/plain/{0}?id=0.7.2"
    req = Request(url.format(MKINITCPIO))
    with open(MKINITCPIO, "wb") as file:
        stat = fstat(file.fileno())
        size = stat.st_size
        UNIT = "bytes"
        if size:
            req.add_header("Range", "{}={}-".format(UNIT, size))
            print("Continuing", req.get_full_url(), file=sys.stderr)
        else:
            print("Downloading", req.get_full_url(), file=sys.stderr)
        with closing(urlopen(req)) as url:
            CONTENT_RANGE = "Content-Range"
            try:
                range = url.info()[CONTENT_RANGE]
            except LookupError:
                range = None
            if range is None:
                file.seek(0)
                total = url.info()["Content-Length"]
                if total is None:
                    print(MKINITCPIO, file=sys.stderr)
                else:
                    msg = "{} {}: {}".format(MKINITCPIO, UNIT, int(total))
                    print(msg, file=sys.stderr)
            else:
                print(CONTENT_RANGE, range, file=sys.stderr)
                if not range.startswith(UNIT):
                    msg = "{} not in {}".format(CONTENT_RANGE, UNIT)
                    raise ValueError(msg)
                range = range[len(UNIT):].lstrip()
                (range, _, total) = range.partition("/")
                (start, _, _) = range.partition("-")
                file.seek(start)
                msg = "{} {}: {}+/{}"
                print(msg.format(MKINITCPIO, UNITS, start, total),
                    file=sys.stderr)
            
            copyfileobj(url, file)
        file.truncate()
        fchmod(file.fileno(), stat.st_mode | S_IXUSR | S_IXGRP | S_IXOTH)

MKINITCPIO="mkinitcpio"

def preset_kver(basedir, preset):
    if not isabs(preset):
        preset = os.path.join(basedir, "etc/mkinitcpio.d",
            preset + ".preset")
    
    script = r"""\
        set -o errexit -o nounset
        BASEDIR="$2"
        . source-transplant.sh
        . "$1"
        printf '%s' "$ALL_kver"
    """
    cmd = ("bash", "-c", script, "--", preset, basedir)
    print("bash", preset)
    try:
        kver = subprocess.check_output(cmd, universal_newlines=True)
    except subprocess.CalledProcessError as e:
        raise SystemExit(e.returncode)
    print("kver", kver)
    
    if isabs(kver):
        # Extract version from boot image; based on
        # https://github.com/glensc/file/blob/master/magic/Magdir/linux
        vmlinuz = os.path.join(basedir, kver.lstrip("/"))
        print("extract version", vmlinuz)
        with open(vmlinuz, "rb") as file:
            if random_read(file, 514, 4) != b"HdrS":
                msg = "Unrecognised Linux boot image: {}".format(vmlinuz)
                raise ValueError(msg)
            
            (value,) = struct.unpack("<H", random_read(file, 510, 2))
            if value != 0xAA55:
                msg = "Unrecognised Linux boot image: {}".format(vmlinuz)
                raise ValueError(msg)
            
            (value,) = struct.unpack("<H", random_read(file, 518, 2))
            if value < 0x200:
                msg = "Unrecognised Linux boot image: {}".format(vmlinuz)
                raise ValueError(msg)
            
            (offset,) = struct.unpack("<H", random_read(file, 526, 2))
            file.seek(0x200 + offset)
            kver = bytearray()
            while True:
                c = file.read(1)
                if not c:
                    msg = "Unterminated version string in {}"
                    raise ValueError(msg.format(vmlinuz))
                if c in b"\0 ":
                    break
                kver.extend(c)
        kver = kver.decode()
        print("kver", kver)
    
    return kver

def splitdoc(doc):
    return doc.split("\n\n", 1)

def random_read(file, offset, size):
    file.seek(offset)
    return file.read(size)

if __name__ == "__main__":
    from argparse import ArgumentParser
    from inspect import getdoc
    (summary, body) = splitdoc(getdoc(sys.modules[__name__]))
    params = ArgumentParser(description=summary, epilog=body)
    params.add_argument("basedir")
    params.add_argument("-p", "--preset", required=True)
    params.add_argument("args", nargs="*", default=[])
    params.add_argument("--skip-depmod", action="store_true")
    args = params.parse_args()
    main(args.basedir, args.preset, *args.args, skip_depmod=args.skip_depmod)
