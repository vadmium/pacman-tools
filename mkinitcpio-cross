#! /usr/bin/env python2
"""
Arch Linux mkinitcpio command without using chroot to allow for cross-
installation of 64-bit OS from 32-bit-only environment.

Requirements:
bash: parse mkinitcpio preset file
"""
from __future__ import print_function

import sys
from os import (
    access, X_OK,
    execv, pathsep, getcwd, environ,
)
import os
import subprocess
from collections import namedtuple
from lib import (transplant, SEEK_CUR)
from collections import defaultdict
import struct
from os.path import commonprefix
from os.path import basename
from lib import Record
from os.path import isabs
from linux_modules import (MODULE_DIR, open_elf)
from lib import strip

try:
    from subprocess import (check_output, CalledProcessError)
except ImportError:
    def check_output(proc_args, *popen_args, **kw):
        proc = subprocess.Popen(proc_args, *popen_args,
            stdout=subprocess.PIPE, **kw)
        (output, _) = proc.communicate()
        if proc.returncode:
            raise EnvironmentError("Command {0} failed with exit status {1}".
                format(proc_args[0], proc.returncode))
        return output

def main(basedir, preset, *args, **kw):
    skip_depmod = kw.pop("skip_depmod", False)
    if kw:
        raise TypeError("Unexpected keyword arguments: {0}".format(
            ", ".join(kw.keys())))

    get_mkinitcpio()
    
    # The "depmod" files installed with the Linux package a refer to module
    # file names ending with ".ko", but the actual file names end with
    # ".ko.gz"
    if not skip_depmod:
        depmod(basedir, preset)
    
    # The "mkinitcpio" script tries to run ". functions", so get it to run
    # our "functions" script first via the search path.
    PATH = "PATH"
    path = getcwd()
    try:
        path = pathsep.join((path, environ[PATH]))
    except LookupError:
        pass
    environ[PATH] = path
    
    environ["BASEDIR"] = basedir
    
    args = (MKINITCPIO, "-p", preset) + args
    print(*args, file=sys.stderr)
    sys.stderr.flush()
    execv(args[0], args)

def get_mkinitcpio():
    if access(MKINITCPIO, X_OK):
        return
    
    from shutil import copyfileobj
    from os import (fstat, fchmod)
    from stat import (S_IXUSR, S_IXGRP, S_IXOTH)
    from contextlib import closing
    
    try:
        from urllib.request import (urlopen, Request)
    except ImportError:
        from urllib2 import (urlopen, Request)
    
    req = Request(
        "https://projects.archlinux.org/{0}.git/plain/{0}?id=0.7.2".
        format(MKINITCPIO))
    with open(MKINITCPIO, "wb") as file:
        stat = fstat(file.fileno())
        size = stat.st_size
        UNIT = "bytes"
        if size:
            req.add_header("Range", "{0}={1}-".format(UNIT, size))
            print("Continuing", req.get_full_url(), file=sys.stderr)
        else:
            print("Downloading", req.get_full_url(), file=sys.stderr)
        with closing(urlopen(req)) as url:
            CONTENT_RANGE = "Content-Range"
            try:
                range = url.info()[CONTENT_RANGE]
            except LookupError:
                range = None
            if range is None:
                file.seek(0)
                total = url.info()["Content-Length"]
                if total is None:
                    print(MKINITCPIO, file=sys.stderr)
                else:
                    print("{0} {1}: {2}".format(
                        MKINITCPIO, UNIT, int(total)), file=sys.stderr)
            else:
                print(CONTENT_RANGE, range, file=sys.stderr)
                if not range.startswith(UNIT):
                    raise ValueError(
                        "{0} not in {1}".format(CONTENT_RANGE, UNIT))
                range = range[len(UNIT):].lstrip()
                (range, _, total) = range.partition("/")
                (start, _, _) = range.partition("-")
                file.seek(start)
                print("{0} {1}: {2}+/{3}".format(
                    MKINITCPIO, UNITS, start, total), file=sys.stderr)
            
            copyfileobj(url, file)
        file.truncate()
        fchmod(file.fileno(), stat.st_mode | S_IXUSR | S_IXGRP | S_IXOTH)

MKINITCPIO="mkinitcpio"

def depmod(basedir, preset):
    """Only generates "modules.dep" and "modules.dep.bin". The real "depmod"
    generates other files as well."""
    if not isabs(preset):
        preset = os.path.join(basedir, "etc/mkinitcpio.d",
            preset + ".preset")
    
    print("bash", preset)
    try:
        kver = check_output(
            "bash -o errexit -o nounset -c".split() + ["""
                    BASEDIR="$2"
                    . source-transplant.sh
                    . "$1"
                    printf '%s' "$ALL_kver"
                """, "kver", preset, basedir],
            bufsize=-1,
            close_fds=True,
        )
    except CalledProcessError as e:
        raise SystemExit(
            "Bash failed with exit status {0}".format(e.returncode))
    print("kver", kver)
    
    if isabs(kver):
        # Extract version from boot image; based on
        # https://github.com/glensc/file/blob/master/magic/Magdir/linux
        vmlinuz = os.path.join(basedir, kver.lstrip("/"))
        print("extract version", vmlinuz)
        with open(vmlinuz, "rb") as file:
            if random_read(file, 514, 4) != b"HdrS":
                raise ValueError(
                    "Unrecognised Linux boot image: {0}".format(vmlinuz))
            
            (value,) = struct.unpack("<H", random_read(file, 510, 2))
            if value != 0xAA55:
                raise ValueError(
                    "Unrecognised Linux boot image: {0}".format(vmlinuz))
            
            (value,) = struct.unpack("<H", random_read(file, 518, 2))
            if value < 0x200:
                raise ValueError(
                    "Unrecognised Linux boot image: {0}".format(vmlinuz))
            
            (offset,) = struct.unpack("<H", random_read(file, 526, 2))
            file.seek(0x200 + offset)
            kver = bytearray()
            while True:
                c = file.read(1)
                if not c:
                    raise ValueError(
                        "Unterminated version string in {0}".format(vmlinuz))
                if c in "\0 ":
                    break
                kver.append(c)
        kver = kver.decode()
        print("kver", kver)
    
    # The following, including some functions called, based on "depmod" from
    # "module-init-tools" (apparently GPL 2)
    
    INDEX_PRIORITY_MIN = ~(~0 << 32)
    
    verify_version(kver)
    
    dirname = os.path.join(basedir, MODULE_DIR, kver)
    print("Scanning modules in", dirname)
    module_files = dict()
    for (dirpath, dirnames, filenames) in os.walk(dirname, followlinks=True):
        #~ print("Scanning", dirpath)
        for f in filenames:
            if not f.endswith((".ko", ".ko.gz")):
                continue
            
            fullpath = os.path.join(dirpath, f)
            pathname = transplant(fullpath, dirname)
            module_files.setdefault(f, Record(
                elf=open_elf(fullpath),
                pathname=pathname,
                order=INDEX_PRIORITY_MIN),
            )
        
        i = 0
        while i < len(dirnames):
            if dirnames[i] in ("source", "build"):
                del dirnames[i]
            else:
                i = i + 1
    
    print('Ordering modules by "modules.order"')
    module_paths = dict((mod.pathname, mod) for mod in module_files.values())
    
    tlist = list()
    file_name = os.path.join(dirname, "modules.order")
    if os.path.exists(file_name):
        with open(file_name, "r") as modorder:
            for (linenum, line) in enumerate(modorder, 1):
                try:
                    mod = module_paths.pop(line)
                except LookupError:
                    continue
                
                mod.order = linenum
                tlist.append(mod)
    tlist.extend(module_paths.values())
    
    print("Reading symbols from modules")
    symbol_owners = dict()
    for (i, mod) in enumerate(tlist):
        print("{0}/{1}".format(i, len(tlist)), end="\r")
        with mod.elf as file:
            # Original "depmod" places later modules at front of hash table
            # chain, so overwrite earlier modules here
            symbol_owners.update((sym, mod)
                for sym in file.get_strings(b"__ksymtab_strings"))
            
            strings = file.get_section(b".strtab")
            syms = file.get_section(b".symtab")
            if strings is not None and syms is not None:
                tables = dict.fromkeys((
                    b"pci", b"usb", b"ccw", b"ieee1394", b"pnp", b"pnp_card",
                    b"input", b"serio", b"of",
                ))
                
                for sym in file.symtab_entries(syms):
                    name = file.read_str(strings, sym.name)
                    try:
                        name = strip(name, b"__mod_", b"_device_table")
                    except ValueError:
                        continue
                    if name not in tables or tables[name] is not None:
                        continue
                    
                    file.file.seek(
                        file.shoff + file.shentsize * sym.shndx + 4)
                    if file.read("L") == (file.SHT_NOBITS,):
                        continue
                    
                    file.file.seek(+file.class_size + file.class_size,
                        SEEK_CUR)
                    (offset,) = file.read(file.class_type)
                    tables[name] = offset + sym.value
    print("{0}/{0}".format(len(tlist)))
    
    print("Reading dependencies of modules")
    for (i, mod) in enumerate(tlist):
        print("{0}/{1}".format(i, len(tlist)), end="\r")
        mod.deps = set()
        with mod.elf as file:
            strings = file.get_section(b".strtab")
            syms = file.get_section(b".symtab")
            if strings is None or syms is None:
                print('{0}: no ".strtab" or ".symtab"'.format(mod.pathname))
                continue
            
            sparc = file.machine in (file.EM_SPARC, file.EM_SPARCV9)
            for sym in file.symtab_entries(syms):
                if (sym.shndx != file.SHN_UNDEF or
                sparc and sym.type == file.STT_SPARC_REGISTER):
                    continue
                
                name = file.read_str(strings, sym.name)
                try:
                    lookup = strip(name, b".")
                except ValueError:
                    lookup = name
                
                try:
                    owner = symbol_owners[lookup]
                except LookupError:
                    continue
                
                #~ print('{0} needs "{1}": {2}'.format(mod.pathname, name,
                    #~ owner.pathname))
                mod.deps.add(owner)
    print("{0}/{0}".format(len(tlist)))
    
    deps_index = defaultdict(list)
    print('Generating "modules.dep"')
    with open(os.path.join(dirname, "modules.dep"), "w") as file:
        for (i, mod) in enumerate(tlist):
            print("{0}/{1}".format(i, len(tlist)), end="\r")
            
            dfs_steps = list()
            ancestors = set()
            visited = set()
            postorder = list()
            
            node = mod
            while True:
                dfs_steps.append(Record(
                    node=node, queue=iter(node.deps)))
                ancestors.add(node)
                
                while dfs_steps:
                    current = dfs_steps[-1]
                    try:
                        node = next(current.queue)
                    except StopIteration:
                        node = current.node
                        ancestors.remove(node)
                        visited.add(node)
                        postorder.append(node)
                        dfs_steps.pop()
                    else:
                        if node in ancestors:
                            print("{0}: Ignoring cyclic dependency of {1} "
                                "on {2}".format(mod.pathname,
                                current.mod.pathname, dep.pathname))
                            continue
                        if node in visited:
                            continue
                        break
                
                if not dfs_steps:
                    break
            
            line = mod.pathname + ":"
            if mod.deps:
                line += " " + " ".join(dep.pathname
                    for dep in reversed(postorder[:-1]))
            file.write(line)
            file.write("\n")
            
            modname = basename(mod.pathname)
            try:
                end = modname.index(".")
            except ValueError:
                pass
            else:
                modname = modname[:end]
            modname = modname.encode("ASCII").replace(b"-", b"_")
            
            # Order must be correspond to modules.order file
            deps_index[modname].append(
                Record(line=line.encode("ASCII"), priority=mod.order))
    
    print('Writing "modules.dep.bin"')
    with open(os.path.join(dirname, "modules.dep.bin"), "wb") as file:
        file.write(struct.pack("!LHH", 0xB007F457, 2, 1))
        if not deps_index:
            deps_index = {b"": None}
        keys = sorted(deps_index.keys())
        branches = [Record(
            prefix=0,
            end=len(keys),
            fixup=file.tell(),
        )]
        file.seek(+4, SEEK_CUR)
        
        NODE_PREFIX = 0x80000000
        NODE_VALUES = 0x40000000
        NODE_CHILDS = 0x20000000
        
        i = 0
        while branches:
            branch = branches.pop()
            first = keys[i]
            last = keys[branch.end - 1]
            node = deps_index[first]
            offset = file.tell()
            
            prefix = commonprefix(
                (first[branch.prefix:], last[branch.prefix:]))
            prefix_len = branch.prefix + len(prefix)
            if len(first) == prefix_len:
                i += 1
            else:
                node = None
            
            if prefix:
                offset |= NODE_PREFIX
                file.write(prefix)
                file.write(b"\x00")
            
            if i < branch.end:
                offset |= NODE_CHILDS
                first = keys[i][prefix_len]
                last = last[prefix_len]
                file.write(first)
                file.write(last)
                
                ch_end = ord(last) + 1
                span = ch_end - ord(first)
                file.write(span * struct.pack("!L", 0))
                fixups = file.tell()
                
                # Branches list is in reverse, so add to it in reverse
                ki = branch.end
                for ci in range(1, 1 + span):
                    ch = ch_end - ci
                    end = ki
                    while ki > i and ord(keys[ki - 1][prefix_len]) == ch:
                        ki -= 1
                    if ki >= end:
                        continue
                    
                    branches.append(Record(
                        prefix=prefix_len + 1,
                        end=end,
                        fixup = fixups - 4 * ci,
                    ))
            
            if node:
                offset |= NODE_VALUES
                file.write(struct.pack("!L", len(node)))
                for v in node:
                    file.write(struct.pack("!L", v.priority))
                    file.write(v.line)
                    file.write(b"\x00")
            
            pos = file.tell()
            file.seek(branch.fixup)
            file.write(struct.pack("!L", offset))
            file.seek(pos)

# Part of GPL 2 "depmod" port
def verify_version(version):
    (major, minor) = slice_int(version)
    if major > 2:
        return
    if major < 2:
        raise ValueError("Required at least Linux version 2")
    
    minor = strip(minor, ".")
    (sub, minor) = slice_int(minor)
    if sub > 5:
        return
    if sub < 5:
        raise ValueError("Required at least Linux version 2.5")
    
    (minor, _) = slice_int(minor)
    if minor < 48:
        raise ValueError("Required at least Linux version 2.5.48")

# The remaining code is not part of the GPL 2 "depmod" port

def slice_int(s):
    for (i, d) in enumerate(s):
        if not d.isdigit():
            break
    else:
        i = len(s)
    return (int(s[:i]), s[i:])

def random_read(file, offset, size):
    file.seek(offset)
    return file.read(size)

from lib import run_main
run_main(__name__)
