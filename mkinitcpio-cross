#! /usr/bin/env python2
"""
Arch Linux mkinitcpio command without using chroot to allow for cross-
installation of 64-bit OS from 32-bit-only environment.

Requirements:
bash: parse mkinitcpio preset file
"""
from __future__ import print_function

import sys
from os import (
    access, X_OK,
    execv, pathsep, getcwd, environ,
)
import os
import subprocess
import struct
from os.path import isabs
from lib import strip
from linux_modules import depmod

try:
    from subprocess import (check_output, CalledProcessError)
except ImportError:
    def check_output(proc_args, *popen_args, **kw):
        proc = subprocess.Popen(proc_args, *popen_args,
            stdout=subprocess.PIPE, **kw)
        (output, _) = proc.communicate()
        if proc.returncode:
            raise EnvironmentError("Command {0} failed with exit status {1}".
                format(proc_args[0], proc.returncode))
        return output

def main(basedir, preset, *args, **kw):
    skip_depmod = kw.pop("skip_depmod", False)
    if kw:
        raise TypeError("Unexpected keyword arguments: {0}".format(
            ", ".join(kw.keys())))

    get_mkinitcpio()
    
    # The "depmod" files installed with the Linux package a refer to module
    # file names ending with ".ko", but the actual file names end with
    # ".ko.gz"
    if not skip_depmod:
        depmod(basedir, preset_kver(basedir, preset))
    
    # The "mkinitcpio" script tries to run ". functions", so get it to run
    # our "functions" script first via the search path.
    PATH = "PATH"
    path = getcwd()
    try:
        path = pathsep.join((path, environ[PATH]))
    except LookupError:
        pass
    environ[PATH] = path
    
    environ["BASEDIR"] = basedir
    
    args = (MKINITCPIO, "-p", preset) + args
    print(*args, file=sys.stderr)
    sys.stderr.flush()
    execv(args[0], args)

def get_mkinitcpio():
    if access(MKINITCPIO, X_OK):
        return
    
    from shutil import copyfileobj
    from os import (fstat, fchmod)
    from stat import (S_IXUSR, S_IXGRP, S_IXOTH)
    from contextlib import closing
    
    try:
        from urllib.request import (urlopen, Request)
    except ImportError:
        from urllib2 import (urlopen, Request)
    
    req = Request(
        "https://projects.archlinux.org/{0}.git/plain/{0}?id=0.7.2".
        format(MKINITCPIO))
    with open(MKINITCPIO, "wb") as file:
        stat = fstat(file.fileno())
        size = stat.st_size
        UNIT = "bytes"
        if size:
            req.add_header("Range", "{0}={1}-".format(UNIT, size))
            print("Continuing", req.get_full_url(), file=sys.stderr)
        else:
            print("Downloading", req.get_full_url(), file=sys.stderr)
        with closing(urlopen(req)) as url:
            CONTENT_RANGE = "Content-Range"
            try:
                range = url.info()[CONTENT_RANGE]
            except LookupError:
                range = None
            if range is None:
                file.seek(0)
                total = url.info()["Content-Length"]
                if total is None:
                    print(MKINITCPIO, file=sys.stderr)
                else:
                    print("{0} {1}: {2}".format(
                        MKINITCPIO, UNIT, int(total)), file=sys.stderr)
            else:
                print(CONTENT_RANGE, range, file=sys.stderr)
                if not range.startswith(UNIT):
                    raise ValueError(
                        "{0} not in {1}".format(CONTENT_RANGE, UNIT))
                range = range[len(UNIT):].lstrip()
                (range, _, total) = range.partition("/")
                (start, _, _) = range.partition("-")
                file.seek(start)
                print("{0} {1}: {2}+/{3}".format(
                    MKINITCPIO, UNITS, start, total), file=sys.stderr)
            
            copyfileobj(url, file)
        file.truncate()
        fchmod(file.fileno(), stat.st_mode | S_IXUSR | S_IXGRP | S_IXOTH)

MKINITCPIO="mkinitcpio"

def preset_kver(basedir, preset):
    if not isabs(preset):
        preset = os.path.join(basedir, "etc/mkinitcpio.d",
            preset + ".preset")
    
    print("bash", preset)
    try:
        kver = check_output(
            "bash -o errexit -o nounset -c".split() + ["""
                    BASEDIR="$2"
                    . source-transplant.sh
                    . "$1"
                    printf '%s' "$ALL_kver"
                """, "kver", preset, basedir],
            bufsize=-1,
            close_fds=True,
        )
    except CalledProcessError as e:
        raise SystemExit(
            "Bash failed with exit status {0}".format(e.returncode))
    print("kver", kver)
    
    if isabs(kver):
        # Extract version from boot image; based on
        # https://github.com/glensc/file/blob/master/magic/Magdir/linux
        vmlinuz = os.path.join(basedir, kver.lstrip("/"))
        print("extract version", vmlinuz)
        with open(vmlinuz, "rb") as file:
            if random_read(file, 514, 4) != b"HdrS":
                raise ValueError(
                    "Unrecognised Linux boot image: {0}".format(vmlinuz))
            
            (value,) = struct.unpack("<H", random_read(file, 510, 2))
            if value != 0xAA55:
                raise ValueError(
                    "Unrecognised Linux boot image: {0}".format(vmlinuz))
            
            (value,) = struct.unpack("<H", random_read(file, 518, 2))
            if value < 0x200:
                raise ValueError(
                    "Unrecognised Linux boot image: {0}".format(vmlinuz))
            
            (offset,) = struct.unpack("<H", random_read(file, 526, 2))
            file.seek(0x200 + offset)
            kver = bytearray()
            while True:
                c = file.read(1)
                if not c:
                    raise ValueError(
                        "Unterminated version string in {0}".format(vmlinuz))
                if c in "\0 ":
                    break
                kver.append(c)
        kver = kver.decode()
        print("kver", kver)
    
    return kver

def random_read(file, offset, size):
    file.seek(offset)
    return file.read(size)

from lib import run_main
run_main(__name__)
