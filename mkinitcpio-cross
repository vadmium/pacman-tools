#! /usr/bin/env python2
from __future__ import print_function

"""
Arch Linux mkinitcpio command without using chroot to allow for cross-
installation of 64-bit OS from 32-bit-only environment.

Requirements:
bash: parse mkinitcpio preset file
"""

import sys
from os import (
    access, X_OK,
    execv, pathsep, getcwd, environ,
)
import os
import subprocess
from collections import namedtuple
import gzip
from io import BytesIO
from contextlib import closing
from lib import (transplant, SEEK_CUR)
import elf

try:
    from subprocess import check_output
except ImportError:
    def check_output(proc_args, *popen_args, **kw):
        proc = subprocess.Popen(proc_args, *popen_args,
            stdout=subprocess.PIPE, **kw)
        (output, _) = proc.communicate()
        if proc.returncode:
            raise EnvironmentError("Command {0} failed with exit status {1}".
                format(proc_args[0], proc.returncode))
        return output

def main():
    (_, basedir, preset) = sys.argv[:3]
    args = sys.argv[2:]
    
    get_mkinitcpio()
    depmod(basedir, preset)
    
    # The "mkinitcpio" script tries to run ". functions", so get it to run
    # our "functions" script first via the search path.
    PATH = "PATH"
    path = getcwd()
    try:
        path = pathsep.join((path, environ[PATH]))
    except LookupError:
        pass
    environ[PATH] = path
    
    environ["BASEDIR"] = basedir
    
    args[:0] = [MKINITCPIO, "-p", preset]
    print(*args, file=sys.stderr)
    sys.stderr.flush()
    execv(args[0], args)

def get_mkinitcpio():
    if access(MKINITCPIO, X_OK):
        return
    
    from shutil import copyfileobj
    from os import (fstat, fchmod)
    from stat import (S_IXUSR, S_IXGRP, S_IXOTH)
    from contextlib import closing
    
    try:
        from urllib.request import (urlopen, Request)
    except ImportError:
        from urllib2 import (urlopen, Request)
    
    req = Request(
        "https://projects.archlinux.org/{0}.git/plain/{0}?id=0.7.2".
        format(MKINITCPIO))
    with open(MKINITCPIO, "wb") as file:
        stat = fstat(file.fileno())
        size = stat.st_size
        UNIT = "bytes"
        if size:
            req.add_header("Range", "{0}={1}-".format(UNIT, size))
            print("Continuing", req.get_full_url(), file=sys.stderr)
        else:
            print("Downloading", req.get_full_url(), file=sys.stderr)
        with closing(urlopen(req)) as url:
            CONTENT_RANGE = "Content-Range"
            try:
                range = url.info()[CONTENT_RANGE]
            except LookupError:
                range = None
            if range is None:
                file.seek(0)
                total = url.info()["Content-Length"]
                if total is None:
                    print(MKINITCPIO, file=sys.stderr)
                else:
                    print("{0} {1}: {2}".format(
                        MKINITCPIO, UNIT, int(total)), file=sys.stderr)
            else:
                print(CONTENT_RANGE, range, file=sys.stderr)
                if not range.startswith(UNIT):
                    raise ValueError(
                        "{0} not in {1}".format(CONTENT_RANGE, UNIT))
                range = range[len(UNIT):].lstrip()
                (range, _, total) = range.partition("/")
                (start, _, _) = range.partition("-")
                file.seek(start)
                print("{0} {1}: {2}+/{3}".format(
                    MKINITCPIO, UNITS, start, total), file=sys.stderr)
            
            copyfileobj(url, file)
        file.truncate()
        fchmod(file.fileno(), stat.st_mode | S_IXUSR | S_IXGRP | S_IXOTH)

MKINITCPIO="mkinitcpio"

def depmod(basedir, preset):
    if not preset.startswith("/"):
        preset = os.path.join(basedir, "etc/mkinitcpio.d",
            preset + ".preset")
    
    kver = check_output(
        "bash -o errexit -o nounset -c".split() + ["""
                . "$1"
                printf '%s' "$ALL_kver"
            """, "kver", preset],
        bufsize=-1,
        close_fds=True,
    )
    
    if kver.startswith("/"):
        # Extract version from boot image; based on
        # https://github.com/glensc/file/blob/master/magic/Magdir/linux
        import struct
        vmlinuz = os.path.join(basedir, kver.lstrip("/"))
        with open(vmlinuz, "rb") as file:
            if random_read(file, 514, 4) != b"HdrS":
                raise ValueError(
                    "Unrecognised Linux boot image: {0}".format(vmlinuz))
            
            (value,) = struct.unpack("<H", random_read(file, 510, 2))
            if value != 0xAA55:
                raise ValueError(
                    "Unrecognised Linux boot image: {0}".format(vmlinuz))
            
            (value,) = struct.unpack("<H", random_read(file, 518, 2))
            if value < 0x200:
                raise ValueError(
                    "Unrecognised Linux boot image: {0}".format(vmlinuz))
            
            (offset,) = struct.unpack("<H", random_read(file, 526, 2))
            file.seek(0x200 + offset)
            kver = bytearray()
            while True:
                c = file.read(1)
                if not c:
                    raise ValueError(
                        "Unterminated version string in {0}".format(vmlinuz))
                if c in "\0 ":
                    break
                kver.append(c)
        kver = kver.decode()
    
    MODULE_DIR = "lib/modules"
    
    if False:
        # Work around clumsy "depmod" program behaviour; see
#https://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;h=bfe5424;a=commitdiff
        depmod_ver = "2.6.0+{0}".format(kver)
        link = os.path.join(basedir, MODULE_DIR, depmod_ver)
        symlink(kver, link)
        try:
            args = ["depmod", "-b", basedir, depmod_ver]
            print(*args, file=sys.stderr)
            subprocess.check_call(args, close_fds=True)
        finally:
            remove(link)
    
    # The following, including some functions called, based on "depmod" from
    # "module-init-tools" (apparently GPL 2)
    
    class Record:
        def __init__(self, *args, **kw):
            self.__dict__.update(dict(*args, **kw))
    
    INDEX_PRIORITY_MIN = ~(~0 << 32)
    
    #~ basedir = "/"; kver="2.6.32-31-generic"
    skipchars = len(basedir)
    
    verify_version(kver)
    
    print("Scanning modules")
    dirname = os.path.join(basedir, MODULE_DIR, kver)
    module_files = dict()
    for (dirpath, dirnames, filenames) in os.walk(dirname, followlinks=True):
        #~ print("Scanning", dirpath)
        for f in filenames:
            if not f.endswith((".ko", ".ko.gz")):
                continue
            
            fullpath = os.path.join(dirpath, f)
            pathname = transplant(fullpath, dirname)
            
            if f.endswith(".gz"):
                with closing(gzip.open(fullpath)) as gz:
                    file = Context(elf.File(BytesIO(gz.read())))
            else:
                file = elf.FileRef(fullpath)
            with file:
                pass
            
            module_files.setdefault(f, Record(elf=file, pathname=pathname))
        
        i = 0
        while i < len(dirnames):
            if dirnames[i] in ("source", "build"):
                del dirnames[i]
            else:
                i = i + 1
    
    print('Ordering modules by "modules.order"')
    module_paths = dict((mod.pathname, mod) for mod in module_files.values())
    
    tlist = list()
    file_name = os.path.join(dirname, "modules.order")
    if os.path.exists(file_name):
        with open(file_name, "r") as modorder:
            for (linenum, line) in enumerate(modorder, 1):
                try:
                    mod = module_paths.pop(line)
                except LookupError:
                    continue
                
                mod.order = linenum
                tlist.append(mod)
    tlist.extend(module_paths.values())
    
    print("Reading dependencies of modules")
    for mod in tlist:
        print(mod["pathname"], mod["elf"])
        with mod["elf"]:
            secname = "__ksymtab_strings"
    #~ load_strings)(module, "__ksymtab_strings"
    
    raise NotImplementedError()

# Part of GPL 2 "depmod" port
def verify_version(version):
    (major, minor) = slice_int(version)
    if major > 2:
        return
    if major < 2:
        raise ValueError("Required at least Linux version 2")
    
    minor = strip(minor, ".")
    (sub, minor) = slice_int(minor)
    if sub > 5:
        return
    if sub < 5:
        raise ValueError("Required at least Linux version 2.5")
    
    (minor, _) = slice_int(minor)
    if minor < 48:
        raise ValueError("Required at least Linux version 2.5.48")

# The remaining code is not part of the GPL 2 "depmod" port

class Context:
    """A dummy context manager that does nothing special"""
    def __init__(self, arg=None):
        self.arg = arg
    def __enter__(self):
        return self.arg
    def __exit__(self, *exc):
        pass

def slice_int(s):
    for (i, d) in enumerate(s):
        if not d.isdigit():
            break
    else:
        i = len(s)
    return (int(s[:i]), s[i:])

def strip(s, start="", end=""):
    if not s.startswith(start):
        raise ValueError("Expected {0!r} starting string".format(start))
    if not s.endswith(end):
        raise ValueError("Expected {0!r} ending string".format(end))
    if len(s) < len(start) + len(end):
        raise ValueError(
            "String not enclosed by {0!r} and {1!r}".format(start, end))
    return s[len(start):len(s) - len(end)]

def random_read(file, offset, size):
    file.seek(offset)
    return file.read(size)

if __name__ == "__main__":
    main()
