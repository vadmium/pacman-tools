#! /usr/bin/env python3
"""
Arch Linux mkinitcpio command without using chroot to allow for cross-
installation of 64-bit OS from 32-bit-only environment.

Requirements:

bash: parse mkinitcpio preset file
"""

import sys
import os
import subprocess
import struct
from os.path import isabs
import os.path
from collections import defaultdict
from argparse import ArgumentParser

def main():
    imageparams = ArgumentParser(add_help=False)
    group = imageparams.add_argument_group("image settings")
    group.add_argument("-k", "--kernel")
    group.add_argument("-c", "--config")
    group.add_argument("-g", "--generate")
    group.add_argument("-S", "--skiphooks", action="append", default=list())
    
    from inspect import getdoc
    (summary, body) = splitdoc(getdoc(sys.modules[__name__]))
    params = ArgumentParser(description=summary, epilog=body,
        parents=(imageparams,))
    params.add_argument("basedir")
    params.add_argument("-p", "--preset")
    
    args = params.parse_args()
    if args.preset is None:
        generate_image(args.basedir, args)
        return
    
    for image in preset_images(args.basedir, args.preset):
        msg = "{}: image {!r}".format(args.preset, image["name"])
        print(msg, file=sys.stderr)
        imageparams.set_defaults(
            kernel=image["kver"],
            config=image["config"],
            generate=image["file"],
        )
        imageargs = imageparams.parse_args(image["options"])
        generate_image(args.basedir, imageargs)

def preset_images(basedir, preset):
    if not {os.sep, os.altsep}.intersection(preset):  # No explicit path
        preset = os.path.join(basedir, "etc", "mkinitcpio.d",
            preset + ".preset")
    
    script = r"""\
        set -o errexit -o nounset
        BASEDIR="$2"
        . source-transplant.sh
        . "$1"
        
        ${PRESETS+printf "PRESETS\0%s\0" "${PRESETS[@]}"}
        for preset in ALL "${PRESETS[@]}"; do
            for suffix in kver config image; do
                var="${preset}_${suffix}"
                ${!var+printf "$var\0%s\0" "${!var}"}
            done
            
            var="${preset}_options"
            options=(${!var-})  # Expand any words into array
            ${options+printf "$var\0%s\0" "${options[@]}"}
        done
    """
    cmd = ("bash", "-c", script, "--", preset, basedir)
    print("bash", preset, file=sys.stderr)
    try:
        serial = subprocess.check_output(cmd)
    except subprocess.CalledProcessError as e:
        raise SystemExit(e.returncode)
    
    serial = serial.split(b"\x00")[:-1]
    vars = defaultdict(list)
    for i in range(len(serial) // 2):
        vars[serial[i + 0]].append(serial[i + 1])
    vars.default_factory = None
    
    for bname in vars[b"PRESETS"]:
        options = vars.get(bname + b"_options", ())
        options = (opt.decode("ascii") for opt in options)
        image = dict(
            name=bname.decode("ascii"),
            file=vars[bname + b"_image"][0],
            options=options,
        )
        for key in ("kver", "config"):
            bkey = key.encode("ascii")
            value = vars.get(bname + b"_" + bkey)
            if value is None:
                value = vars[b"ALL_" + bkey]
            image[key] = os.fsdecode(value[0])
        yield image

def generate_image(basedir, args):
    if args.config is None:
        configfile = ("etc", "mkinitcpio.conf")
    else:
        configfile = (args.config.lstrip("/"),)
    configfile = os.path.join(basedir, *configfile)

def get_kver(basedir, kver):
    print("kver", kver, file=sys.stderr)
    
    if isabs(kver):
        # Extract version from boot image; based on
        # https://github.com/glensc/file/blob/master/magic/Magdir/linux
        vmlinuz = os.path.join(basedir, kver.lstrip("/"))
        print("extract version", vmlinuz, file=sys.stderr)
        with open(vmlinuz, "rb") as file:
            if random_read(file, 514, 4) != b"HdrS":
                msg = "Unrecognised Linux boot image: {}".format(vmlinuz)
                raise ValueError(msg)
            
            (value,) = struct.unpack("<H", random_read(file, 510, 2))
            if value != 0xAA55:
                msg = "Unrecognised Linux boot image: {}".format(vmlinuz)
                raise ValueError(msg)
            
            (value,) = struct.unpack("<H", random_read(file, 518, 2))
            if value < 0x200:
                msg = "Unrecognised Linux boot image: {}".format(vmlinuz)
                raise ValueError(msg)
            
            (offset,) = struct.unpack("<H", random_read(file, 526, 2))
            file.seek(0x200 + offset)
            kver = bytearray()
            while True:
                c = file.read(1)
                if not c:
                    msg = "Unterminated version string in {}"
                    raise ValueError(msg.format(vmlinuz))
                if c in b"\0 ":
                    break
                kver.extend(c)
        kver = kver.decode()
        print("kver", kver, file=sys.stderr)
    
    return kver

def splitdoc(doc):
    return doc.split("\n\n", 1)

def random_read(file, offset, size):
    file.seek(offset)
    return file.read(size)

if __name__ == "__main__":
    main()
