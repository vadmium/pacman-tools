#! /usr/bin/env python2
from __future__ import print_function

# Reference: https://www.sco.com/developers/gabi/latest/contents.html

from sys import argv
import os
from stat import (S_ISUID, S_ISGID)
from glob import iglob
import elf
from lib import transplant
from lib import Cleanup

def main():
    (_, root) = argv[:2]
    exes = argv[2:]
    for exe in exes:
        if len(exes) != 1:
            print("{0}:".format(exe))
        ElfResolve(root, exe)

class ElfResolve:
    def __init__(self, root, name):
        self.root = root
        self.soname_paths = dict()
        self.deflibs = Thunk(ldconfig_parse, self.root, "/etc/ld.so.conf")
        self.depends = set()
        exe_queue = [name]
        exe_seen = set(exe_queue)
        while exe_queue:
            self.needed_queue = []
            self.needed_seen = set(self.needed_queue)
            self.name = exe_queue.pop()
            self.privileged = is_privileged(self.name)
            for seg in self.ph_entries():
                if seg.type == self.elf.PT_INTERP:
                    interp = (self.elf.read_str((seg.offset, seg.filesz)).
                        decode())
                    if interp not in self.depends:
                        self.depends.add(interp)
                        print("\t{0} (0x0)".format(interp))
                    
                    interp = transplant(interp, new=self.root)
                    if interp not in exe_seen:
                        exe_queue.append(interp)
                        exe_seen.add(interp)
                
                self.parse_dynamic(seg)
            
            while self.needed_queue:
                self.name = transplant(self.needed_queue.pop(),
                    new=self.root)
                for seg in self.ph_entries():
                    self.parse_dynamic(seg)
    
    def ph_entries(self):
        with elf.FileRef(self.name) as self.elf:
            self.origin = Thunk(self.get_origin)
            
            if self.elf.phoff:
                self.get_dynamic = Thunk(self.elf.read_dynamic)
                self.get_rpath = Thunk(self.elf.read_dyn_list,
                    self.get_dynamic, "rpath")
                self.get_runpath = Thunk(self.elf.read_dyn_list,
                    self.get_dynamic, "runpath")
                
                for seg in self.elf.ph_entries():
                    yield seg
    
    def parse_dynamic(self, seg):
        if seg.type != self.elf.PT_DYNAMIC:
            return
        
        for tag in self.elf.pt_dynamic_entries(seg):
            if tag != self.elf.DT_NEEDED:
                continue
            
            (offset,) = self.elf.read(self.elf.class_type)
            self.dynamic = self.get_dynamic()
            
            raw_needed = (self.elf.read_str(self.dynamic.strtab, offset).
                decode())
            needed = self.sub_origin(raw_needed)
            
            if "/" not in needed:
                for path in self.search_paths():
                    try:
                        needed = self.search_sonames(path, needed)
                    except LookupError:
                        pass
                    else:
                        break
                else:
                    print("\t{0} => not found".format(raw_needed))
                    continue
            
            if needed not in self.depends:
                self.depends.add(needed)
                print("\t{0} => {1} (0x0)".format(raw_needed, needed))
            if needed not in self.needed_seen:
                self.needed_queue.append(needed)
                self.needed_seen.add(needed)
    
    def search_paths(self):
        if not self.dynamic.runpath:
            for dirs in self.get_rpath():
                for dir in dirs.split(b":"):
                    yield dir.decode()
        
        if not self.privileged:
            try:
                search = os.environ["LD_LIBRARY_PATH"]
            except LookupError:
                pass
            else:
                for dirs in search.split(";"):
                    for dir in dirs.split(":"):
                        yield dir
        
        for dirs in self.get_runpath():
            for dir in dirs.split(b":"):
                try:
                    dir = self.sub_origin(dir.decode())
                except ValueError:
                    pass
                else:
                    yield dir
        
        for dir in self.deflibs():
            yield dir
    
    def search_sonames(self, path, needed):
        if path not in self.soname_paths:
            #~ print("Searching object path", path)
            rebased = transplant(path, new=self.root)
            sonames = dict()
            
            try:
                list = os.listdir(rebased)
            except EnvironmentError:
                list = []
            elfs = set()
            for file in list:
                with Cleanup() as cleanup:
                    try:
                        probe = cleanup(
                            elf.FileRef(os.path.join(rebased, file)))
                    except (EnvironmentError, ValueError):
                        continue
                    
                    if not self.elf.matches(probe):
                        continue
                    
                    elfs.add(file)
                    for soname in probe.read_dyn_list(
                    Thunk(probe.read_dynamic), "soname"):
                        soname = soname.decode()
                        if soname in sonames and soname != file:
                            continue
                        sonames[soname] = file
            
            sonames.update((file, file)
                for file in elfs if file not in sonames)
            
            self.soname_paths[path] = sonames
        return os.path.join(path, self.soname_paths[path][needed])
    
    def get_origin(self):
        origin = os.path.realpath(self.path.dirname(self.name))
        return transplant(origin, old=os.path.realpath(self.root), new="/")
    
    def sub_origin(self, str):
        subs = ("$ORIGIN", "${ORIGIN}")
        if all(sub not in str for sub in subs):
            return str
        if self.privileged:
            raise ValueError("$ORIGIN substitution used "
                "for privileged executable: {0}".format(str))
        
        frags0 = str.split(subs[0])
        frags1 = []
        for f in frags0:
            frags1.extend(f.split(subs[1]))
        return self.origin().join(frags1)

def ldconfig_parse(root, conf):
    dirs = []
    incs = [iter((transplant(conf, new=root),))]
    files = []
    try:
        while True:
            try:
                files.append(LdConfigFile(next(incs[-1])))
            except StopIteration:
                incs.pop()
            
            if not files:
                break
            
            while True:
                word = files[-1].read_word()
                
                if not word:
                    files[-1].close()
                    files.pop()
                    break
                
                if word == "include":
                    inc = files[-1].read_word()
                    if not inc:
                        raise TypeError("include at EOF")
                    incs.append(iglob(transplant(inc, new=root)))
                    break
                
                dirs.append(word)
    finally:
        while files:
            files.pop().close()
    
    dirs.extend(("/lib", "/usr/lib"))
    return dirs

class LdConfigFile:
    def __init__(self, name):
        self.file = open(name)
        try:
            self.c = self.file.read(1)
        except:
            self.file.close()
            raise
    
    def read_word(self):
        while True:
            if self.c == "#":
                while True:
                    self.c = self.file.read(1)
                    if not self.c or self.c in "\r\n":
                        break
            
            if not self.c or self.c not in self.SEPS:
                break
            
            self.c = self.file.read(1)
        
        word = ""
        while self.c and self.c not in self.SEPS:
            word += self.c
            self.c = self.file.read(1)
        
        return word
    
    def close(self, *args, **kw):
        return self.file.close(*args, **kw)
    
    SEPS = ": \t\r\n,"

def is_privileged(name):
    return os.stat(name).st_mode & (S_ISUID | S_ISGID)

class Thunk:
    def __init__(self, *args, **kw):
        if not hasattr(self, "res") and args:
            self.func = args[0]
            self.args = args[1:]
            self.kw = kw
    def __call__(self):
        try:
            return self.res
        except AttributeError:
            pass
        self.res = self.func(*self.args, **self.kw)
        del (self.func, self.args, self.kw)
        return self.res

if "__main__" == __name__:
    main()
