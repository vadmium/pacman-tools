#! /usr/bin/env python2
from __future__ import print_function

# Reference: https://www.sco.com/developers/gabi/latest/contents.html

from sys import argv
import os
from stat import (S_ISUID, S_ISGID)
from glob import iglob
import elf
from lib import transplant
from lib import Cleanup

def main():
    (_, root) = argv[:2]
    exes = argv[2:]
    for exe in exes:
        if len(exes) != 1:
            print("{0}:".format(exe))
        ElfResolve(root, exe)

class ElfResolve:
    def __init__(self, root, name):
        self.soname_paths = dict()
        self.depends = set()
        exe_queue = [name]
        exe_seen = set(exe_queue)
        while exe_queue:
            self.needed_queue = []
            self.needed_seen = set(self.needed_queue)
            self.name = exe_queue.pop()
                if seg.type == self.elf.PT_INTERP:
                    if interp not in self.depends:
                        self.depends.add(interp)
                        print("\t{0} (0x0)".format(interp))
                    
                    interp = transplant(interp, new=self.root)
                    if interp not in exe_seen:
                        exe_queue.append(interp)
                        exe_seen.add(interp)
                
                self.parse_dynamic(seg)
            
            while self.needed_queue:
                self.name = transplant(self.needed_queue.pop(),
                    new=self.root)
                for seg in self.ph_entries():
                    self.parse_dynamic(seg)
    
    def ph_entries(self):
        with elf.FileRef(self.name) as self.elf:
            self.origin = Thunk(self.get_origin)
            
            if self.elf.phoff:
                self.get_dynamic = Thunk(self.elf.read_dynamic)
                self.get_rpath = Thunk(self.elf.read_dyn_list,
                    self.get_dynamic, "rpath")
                self.get_runpath = Thunk(self.elf.read_dyn_list,
                    self.get_dynamic, "runpath")
                
                for seg in self.elf.ph_entries():
                    yield seg
    
    def parse_dynamic(self, seg):
                for path in self.search_paths():
                    try:
                        needed = self.search_sonames(path, needed)
                    except LookupError:
                        pass
                    else:
                        break
                else:
                    print("\t{0} => not found".format(raw_needed))
                    continue
            
            if needed not in self.depends:
                self.depends.add(needed)
                print("\t{0} => {1} (0x0)".format(raw_needed, needed))
            if needed not in self.needed_seen:
                self.needed_queue.append(needed)
                self.needed_seen.add(needed)
    
    def search_sonames(self, path, needed):
        if path not in self.soname_paths:
            #~ print("Searching object path", path)
            rebased = transplant(path, new=self.root)
            sonames = dict()
            
            try:
                list = os.listdir(rebased)
            except EnvironmentError:
                list = []
            elfs = set()
            for file in list:
                with Cleanup() as cleanup:
                    try:
                        probe = cleanup(
                            elf.FileRef(os.path.join(rebased, file)))
                    except (EnvironmentError, ValueError):
                        continue
                    
                    if not self.elf.matches(probe):
                        continue
                    
                    elfs.add(file)
                    for soname in probe.read_dyn_list(
                    Thunk(probe.read_dynamic), "soname"):
                        soname = soname.decode()
                        if soname in sonames and soname != file:
                            continue
                        sonames[soname] = file
            
            sonames.update((file, file)
                for file in elfs if file not in sonames)
            
            self.soname_paths[path] = sonames
        return os.path.join(path, self.soname_paths[path][needed])
    
    def get_origin(self):
        origin = os.path.realpath(os.path.dirname(self.name))
        return transplant(origin, old=os.path.realpath(self.root), new="/")

def ldconfig_parse(root, conf):
    dirs = []
    incs = [iter((transplant(conf, new=root),))]
    files = []
    try:
        while True:
            try:
                files.append(LdConfigFile(next(incs[-1])))
            except StopIteration:
                incs.pop()
            
            if not files:
                break
            
            while True:
                word = files[-1].read_word()
                
                if not word:
                    files[-1].close()
                    files.pop()
                    break
                
                if word == "include":
                    inc = files[-1].read_word()
                    if not inc:
                        raise TypeError("include at EOF")
                    incs.append(iglob(transplant(inc, new=root)))
                    break
                
                dirs.append(word)
    finally:
        while files:
            files.pop().close()
    
    dirs.extend(("/lib", "/usr/lib"))
    return dirs

class LdConfigFile:
    def __init__(self, name):
        self.file = open(name)
        try:
            self.c = self.file.read(1)
        except:
            self.file.close()
            raise
    
    def read_word(self):
        while True:
            if self.c == "#":
                while True:
                    self.c = self.file.read(1)
                    if not self.c or self.c in "\r\n":
                        break
            
            if not self.c or self.c not in self.SEPS:
                break
            
            self.c = self.file.read(1)
        
        word = ""
        while self.c and self.c not in self.SEPS:
            word += self.c
            self.c = self.file.read(1)
        
        return word
    
    def close(self, *args, **kw):
        return self.file.close(*args, **kw)
    
    SEPS = ": \t\r\n,"

def is_privileged(name):
    return os.stat(name).st_mode & (S_ISUID | S_ISGID)

if "__main__" == __name__:
    main()
