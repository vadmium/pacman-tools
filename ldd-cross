#! /usr/bin/env python2
from __future__ import print_function

# Reference: https://www.sco.com/developers/gabi/latest/contents.html

from sys import argv
import os
import elf
from lib import transplant

def main():
    (_, root) = argv[:2]
    exes = argv[2:]
    for exe in exes:
        if len(exes) != 1:
            print("{0}:".format(exe))
        ElfResolve(root, exe)

class ElfResolve:
    def __init__(self, root, name):
        self.depends = set()
        exe_queue = [name]
        exe_seen = set(exe_queue)
        while exe_queue:
            self.needed_queue = []
            self.needed_seen = set(self.needed_queue)
            self.name = exe_queue.pop()
                if seg.type == self.elf.PT_INTERP:
                    if interp not in self.depends:
                        self.depends.add(interp)
                        print("\t{0} (0x0)".format(interp))
                    
                    interp = transplant(interp, new=self.root)
                    if interp not in exe_seen:
                        exe_queue.append(interp)
                        exe_seen.add(interp)
                
                self.parse_dynamic(seg)
            
            while self.needed_queue:
                self.name = transplant(self.needed_queue.pop(),
                    new=self.root)
                for seg in self.ph_entries():
                    self.parse_dynamic(seg)
    
    def ph_entries(self):
        with elf.FileRef(self.name) as self.elf:
            self.origin = Thunk(self.get_origin)
            
            if self.elf.phoff:
                self.get_dynamic = Thunk(self.elf.read_dynamic)
                self.get_rpath = Thunk(self.elf.read_dyn_list,
                    self.get_dynamic, "rpath")
                self.get_runpath = Thunk(self.elf.read_dyn_list,
                    self.get_dynamic, "runpath")
                
                for seg in self.elf.ph_entries():
                    yield seg
    
    def parse_dynamic(self, seg):
                for path in self.search_paths():
                    try:
                        needed = self.search_sonames(path, needed)
                    except LookupError:
                        pass
                    else:
                        break
                else:
                    print("\t{0} => not found".format(raw_needed))
                    continue
            
            if needed not in self.depends:
                self.depends.add(needed)
                print("\t{0} => {1} (0x0)".format(raw_needed, needed))
            if needed not in self.needed_seen:
                self.needed_queue.append(needed)
                self.needed_seen.add(needed)

if "__main__" == __name__:
    main()
