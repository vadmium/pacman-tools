#! /bin/sh

# Arch Linux installation without using chroot or executing target programs
# to allow for cross-installation of 64-bit OS from 32-bit-only environment.

# Requirements:
# tar,wget,sed,grep,comm,sort,uniq,mktemp,sh
# Optional:
# xz-utils: xz packages
# uname: architecture default
# cpio: building bundle
# sudo: installing root filesystem
# sudo: cache access
# Recommended: fakeroot: building bundle 
# Recommended: sudo: installing root filesystem
# Recommended: sudo: cache access

# TODO:
# Try cpio instead of tar, and pax instead of both; configurable or automatically tried
# check remote server for newer versions of files (eg package database)
# cross makepkg? otherwise, only really build "any" arch packages

set -o errexit -o nounset
WS="$IFS"
NL='
'

while test "$#" -gt 0; do
    case "$1" in
    fs) # default: ./stage, and delete when finished
        DESTDIR="$2"
        shift 2;;
    bundle)
        BUNDLE="$2"
        shift 2;;
    fs-axx) # default: fakeroot -- if staged
        FSX="$2"
        shift 2;;
    fs-sudo)
        FSX="sudo -E --"
        shift;;
    repo)
        # multiple options; additional to those from pacman.conf;
        # recommended:
        # http://mirrors.kernel.org/archlinux/<repo>/os/$arch/<repo>.db for
        # <repo> in core,extra,community
        for repo in $2; do
            REPOS="${REPOS+$REPOS$NL}$repo"
        done
        shift 2;;
    config) # default: /etc/pacman.conf
        CONFIG="$2"
        shift 2;;
    cache-axx) # default: nothing
        CX="$2"
        shift 2;;
    cache-sudo)
        CX="sudo -E --"
        shift;;
    install) # multiple options; recommended: base
        IFS="$WS,"
        INSTALL="${INSTALL+$INSTALL$NL}$(printf '%s\n' $2)"
        shift 2;;
    build) # multiple options; PKGBUILD or directory containing one
        echo "Not implemented" >&2
        false
        shift 2;;
    arch) # default: uname -m
        arch="$2"
        shift 2;;
    enable)
        IFS="$WS,"
        ENABLE="${ENABLE+$ENABLE$NL}$(printf '%s\n' $2)"
        shift 2;;
    disable) # recommended: testing
        IFS="$WS,"
        DISABLE="${DISABLE+$DISABLE$NL}$(printf '%s\n' $2)"
        shift 2;;
    offline)
        OFFLINE=set
        shift 1;;
    *)
        echo "Bad option: $1" >&2
        false
        shift 1;;
    esac
done

: "${CONFIG=/etc/pacman.conf}"
: "${CX=}"

if test ! -v DESTDIR; then
    : "${FSX=}"
else
    : "${FSX=fakeroot --}"
fi

if test -v arch; then
    # Don't use Pacman's database if we override the architecture
    : "${DBPATH=.}"
fi

if test -e "$CONFIG"; then
    unset line
    
    ini_line() {
        unset line
        while read -r line; do
            case "$line" in
            '['*']')
                return 1;;
            '#'* | '')
                continue;;
            esac
            
            key="$(printf '%s\n' "$line" | sed 's/[ \t\n]*=.*$//')"
            value="$(printf '%s\n' "$line" | sed 's/^[^=]*=\?[ \t\n]*//')"
            return 0
        done
        return 1
    }
    
    while test -v line || read -r line; do
        case "$line" in
        '[options]')
            while ini_line; do
                case "$key" in
                RootDir)
                    if test ! -v BUNDLE; then
                        : "${DESTDIR="$value"}"
                    fi;;
                DBPath)
                    : "${DBPATH="$value"}";;
                CacheDir)
                    : "${CACHEDIR="$value"}";;
                Architecture)
                    if test "$value" != auto; then
                        : "${arch="$value"}"
                    fi;;
                esac
            done;;
        
        '['*']')
            repo="${line#'['}"
            repo="${repo%']'}"
            if {
                test -v ENABLE &&
                ! printf '%s\n' "$ENABLE" | grep -qFx -- "$repo"
            } || {
                test -v DISABLE &&
                printf '%s\n' "$DISABLE" | grep -qFx -- "$repo"
            } then
                unset line
                continue
            fi
            
            unset server
            while ini_line; do
                case "$key" in
                Include)
                    while ini_line; do
                        if test "$key" = Server; then
                            : "${server="$value"}"
                        fi
                    done < "$value";;
                Server)
                    : "${server="$value"}";;
                esac
            done
            
            server="$(printf '%s/$repo.db\n' "$server" |
                sed s/'$repo'/"$repo"/g)"
            REPOS="${REPOS+$REPOS$NL}$server";;
        
        *)
            unset line;;
        esac
    done < "$CONFIG"
    
    : "${DBPATH=/var/lib/pacman}" "${CACHEDIR=/var/cache/pacman/pkg}"
fi

: "${DBPATH=.}" "${CACHEDIR=pkg}"

if test ! -v arch; then
    arch="$(uname -m)"
fi
REPOS="$(printf '%s\n' "$REPOS" | sed s/'$arch'/"$arch"/g)"

WGET="wget"
#WGET="wget --no-verbose"

unset SCRATCH FS

onexit() {
    IFS="$WS"
    echo >&2 "cleaning up"
    $CX rm "$DBPATH/db.lck"
    if test -v SCRATCH; then
        rm -rf "$SCRATCH"
    fi
    if test -v FS; then
        $FSX rm -rf "$FS"
    fi
}

IFS="$WS"
$CX mkdir -p "$DBPATH"
PID="$$" LOCK="$DBPATH/db.lck" $CX sh -o noclobber -c 'echo "$PID" > "$LOCK"'
trap onexit EXIT

$FSX mkdir "${DESTDIR-stage}"
FS="${DESTDIR-stage}"
$CX mkdir -p "$DBPATH/sync"
$CX mkdir -p "$CACHEDIR"

if test ! -v OFFLINE; then
    printf '%s\n' "$REPOS" |
    $CX $WGET --timestamping --directory-prefix="$DBPATH/sync" -i -
fi

SCRATCH="$(mktemp --tmpdir --directory pkgb.XXXXXXXXXX)"

if test -v INSTALL; then printf '%s\n' "$INSTALL"; fi |
sort -u > "$SCRATCH/search"

IFS="$NL"
mkdir "$SCRATCH/db"
for repo in $REPOS; do
    db="${repo##*/}"
    mkdir "$SCRATCH/db/$db"
    echo >&2 "Reading: $db"
    tar xf "$DBPATH/sync/$db" -C "$SCRATCH/db/$db" -k
done

total=0
: > "$SCRATCH/resolved"
while test -s "$SCRATCH/search"; do
    echo >&2 "Resolving:" $(< "$SCRATCH/search")
    unset new_deps
    
    IFS="$NL"
    for repo in $REPOS; do
        db="${repo##*/}"
        echo >&2 "  Searching: $db"
        repo="$(printf '%s\n' "$repo" | sed 's:[^/]*$::')"
        
        for pkg in "$SCRATCH/db/$db"/*; do
            unset provs groups deps filename
            size=0
            
            while read -r line; do
                case "$line" in
                %FILENAME%)
                    while read -r line && test -n "$line"; do
                        filename="${filename+$filename$NL}$repo$line"
                    done;;
                %NAME%)
                    while read -r line && test -n "$line"; do
                        provs="${provs+$provs$NL}$line"
                    done;;
                %GROUPS%)
                    while read -r line && test -n "$line"; do
                        groups="${groups+$groups$NL}$line"
                    done;;
                %ISIZE%)
                    while read -r line && test -n "$line"; do
                        size="$((size + line))"
                    done;;
                esac
            done < "$pkg/desc"
            
            if test -e "$pkg/depends"; then
                while read -r line; do
                    case "$line" in
                    %DEPENDS%)
                        while read -r line && test -n "$line"; do
                            line="${line%%[>=]*}"
                            deps="${deps+$deps$NL}$line"
                        done;;
                    %PROVIDES%)
                        while read -r line && test -n "$line"; do
                            line="${line%%=*}"
                            provs="${provs+$provs$NL}$line"
                        done;;
                    esac
                done < "$pkg/depends"
            fi
            
            if test -v groups; then
                ! groups="$(grep -Fx "$groups" "$SCRATCH/search")"
            fi
            if {
                test -z "${groups-}" &&
                ! grep -qFx -- "$provs" "$SCRATCH/search"
            } || grep -qFx -- "$provs" "$SCRATCH/resolved"; then
                continue
            fi
            
            pkgs="${pkgs+$pkgs$NL}$filename"
            if test -v deps; then
                new_deps="${new_deps+$new_deps$NL}$deps"
            fi
            printf '%s\n' "$provs" >> "$SCRATCH/resolved"
            if test -v groups; then
                printf '%s\n' "$groups" >> "$SCRATCH/resolved"
            fi
            total="$((total + size))"
        done
    done
    
    sort -u -- "$SCRATCH/resolved" > "$SCRATCH/out"
    mv "$SCRATCH/out" "$SCRATCH/resolved"
    
    unres="$(comm -23 -- "$SCRATCH/search" "$SCRATCH/resolved")"
    if test -n "$unres"; then
        IFS="$NL"
        echo >&2 "Unresolved packages:" $unres
        false
    fi
    
    if test -v new_deps; then printf '%s\n' "$new_deps"; fi |
    sort -u | comm -23 - -- "$SCRATCH/resolved" > "$SCRATCH/search"
done
echo >&2 "Total install size: $total"

if test ! -v OFFLINE; then
    IFS="$WS"
    printf '%s\n' "$pkgs" |
    $CX $WGET -c --directory-prefix="$CACHEDIR" -i -
fi

printf '%s\n' "$pkgs" | sed 's:^.*/::' | {
    cat << 'SH' > "$SCRATCH/script"
        set -o errexit -o nounset
        
        INSTALL="$FS/var/lib/pkgbundle/install.d"
        mkdir -p "$INSTALL"
        while read -r line; do
            echo "$line" >&2
            tar xf "$CACHEDIR/$line" --force-local -C "$FS" -k --exclude .CHANGELOG
            pkgname="$(sed -n 's/^pkgname = //p' -- "$FS/.PKGINFO")"
            rm -- "$FS/.PKGINFO"
            if test -e "$FS/.INSTALL"; then
                mv -- "$FS/.INSTALL" "$INSTALL/$pkgname"
            fi
        done
        
        if test -n "$BUNDLE"; then
            echo "Creating $BUNDLE" >&2
            cd "$FS"
            find . | cpio -o -H newc
        fi
SH
    
    IFS="$WS"
    FS="$FS" CACHEDIR="$CACHEDIR"  BUNDLE="${BUNDLE-}" $FSX sh \
        "$SCRATCH/script"
} | if test -v BUNDLE; then
    gzip -c > "$BUNDLE"
fi

if test -v DESTDIR; then
    unset FS
fi
