#! /usr/bin/env python3

from sys import argv
from subprocess import (check_call, Popen)
import subprocess

"""
CACHEDIR=/var/cache/pacman/pkg
"""

def main():
    through = list()
    refresh = []
    sync = []
    upgrade = []
    args = iter(argv[1:])
    for arg in args:
        while True:
            strung = arg.startswith("-") and arg[1] != "-" and len(arg) > 2
            if strung:
                opt = arg[:1 + 1]
            else:
                opt = arg
            
            if opt in ("-S", "--sync"):
                sync.append(opt)
            elif opt in ("-y", "--refresh"):
                refresh.append(opt)
            elif opt in ("-U", "--upgrade"):
                upgrade.append(opt)
            else:
                through.append(arg)
                through.extend(args)
                break
            
            if strung:
                arg = "-" + arg[1 + 1:]
            else:
                break
    
    if upgrade:
        pkgs = through
    else:
        check_call(
            ["pacman"] + sync + refresh + ["--downloadonly"] + through)
        
        pkgs = list()
        with Popen(["pacman"] + sync + ["--print"] + through, bufsize=-1,
        stdout=subprocess.PIPE) as pacman:
            for line in pacman.stdout:
                print(line)
        """
        pkgs="$(
            while read -r pkg; do
                echo "$CACHEDIR/$(basename -- "$pkg")"
            done << INPUT
$pkgs
INPUT
        )"
    
    unset WORK
    trap onexit EXIT
    
    while read -r pkg; do
        WORK="$(mktemp --tmpdir --directory roopwn.XXXXXXXXXX)"
        echo >&2
        echo >&2 "Analysing:" "$pkg"
        local files file deps missing fail
        files="$(tar xvf "$pkg" -C "$WORK" --exclude ".*" --anchored)"
        while read -r file; do
            workfile="$WORK/$file"
            
            if ! {
                test -x "$workfile" &&
                interp="$(
                    readelf --program-headers -- "$workfile" 2> /dev/null)"
            } then
                continue
            fi
            interp="$(sed -n \
            's/^ *\[Requesting program interpreter: \([^]]*\)\].*$/\1/p' \
                << INPUT
$interp
INPUT
            )"
            if test ! -e; then
                echo >&2 "$file: $interp: interp not found"
                fail=set
            fi
            
            needed="$(readelf --dynamic -- "$workfile")"
            # TODO: handle dynamic entries with RPATH and RUNPATH tags
            needed="$(sed -n \
            's/^ *[^ ]\+ *(NEEDED) *Shared library: \[\([^]]*\)\].*$/\1/p' \
                << INPUT
$deps
INPUT
            )"
            # TODO: handle absolute path; expand $ORIGIN
            
            echo >&2 "$file: needed: $deps"
            fail=set
        done << INPUT
$files
INPUT
        onexit
    done << INPUT
$pkgs
INPUT
    
    if test -n "${fail-}"; then
        return 1
    fi
    
    IFS="$NL"
    pacman --upgrade $pkgs
}

onexit() {
    if test -n "${WORK+set}"; then
        rm -rf -- "$WORK"
    fi
    unset WORK
}
"""

if __name__ == "__main__":
    main()
