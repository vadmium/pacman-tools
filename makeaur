#! /usr/bin/env python3

import subprocess
from io import StringIO, BytesIO, BufferedIOBase
import tarfile
from time import time
from os import fsdecode
from stat import S_IRUSR, S_IWUSR, S_IXUSR
from stat import S_IRGRP, S_IXGRP, S_IROTH, S_IXOTH
from contextlib import contextmanager
import gzip
import selectors
from select import PIPE_BUF

"""
The original tar file is signed, and the signature is appended to the tar
stream, after the original EOF block, as another tar file stream. Equivalent
commands using GNU "tar" and GNU Privacy Guard:

$ gzip --decompress --stdout < *.src.tar.gz |
>     gpg --detach-sign > example/signature
$ {
>     gzip --decompress --stdout &&
>     tar --create */signature
> } < *.src.tar.gz | gzip --stdout > tmp
$ mv tmp *.src.tar.gz

The appended signature file is ignored by "tar" by default:

$ tar --file *.tar.gz --list
example/
example/.AURINFO
example/PKGBUILD

To verify the signature, one needs to know where the original tar file stream
ends. Typically this is 10240 bytes from the final end of file:

$ tar --file *.tar.gz --ignore-zeros --extract --verbose
example/
example/.AURINFO
example/PKGBUILD
example/signature
$ gzip --decompress --stdout < *.tar.gz |
>     head --bytes=-10240 | gpg --verify */signature -
"""

def main(p="PKGBUILD"):
    proc = getaurinfo(p)
    (aurinfo, _) = proc.communicate()
    if proc.returncode:
        raise SystemExit(proc.returncode)
    pkg = parseaurinfo(aurinfo)
    aurtar = AurTar(pkg["pkgbase"], pkg["pkgver"])
    with aurtar.context():
        aurtar.addfile(".AURINFO", BytesIO(aurinfo), size=len(aurinfo))
        aurtar.addosfile(p, "PKGBUILD")
        for field in FILE_FIELDS:
            file = pkg.get(field)
            if file:
                aurtar.addosfile(file)
        for source in pkg["source"]:
            if b":" not in source:
                aurtar.addosfile(source)

class AurTar:
    def __init__(self, pkgname, pkgver):
        self.pkgname = fsdecode(pkgname)
        self.name = "{}-{}.src.tar.gz".format(self.pkgname, fsdecode(pkgver))
    
    @contextmanager
    def context(self):
        with gzip.open(self.name, "w") as file:
            gpg = ("gpg", "--detach-sign")
            sig = BytesIO()
            gpg = SubprocessWriter(gpg, stdout_writer=sig)
            with gpg.context():
                self.tar = TeeWriter(file, gpg)
                self.tar = tarfile.open(fileobj=self.tar, mode="w|")
                self.mtime = time()
                
                tarinfo = tarfile.TarInfo(self.pkgname)
                tarinfo.mtime = self.mtime
                tarinfo.type = tarfile.DIRTYPE
                tarinfo.mode = (S_IRUSR | S_IWUSR | S_IXUSR |
                    S_IRGRP | S_IXGRP |  S_IROTH | S_IXOTH)
                self.tar.addfile(tarinfo)
                
                yield
                self.tar.close()
            self.tar = tarfile.open(fileobj=file, mode="w|")
            size = sig.tell()
            sig.seek(0)
            self.addfile("signature", sig, size=size)
            self.tar.close()
    
    def addfile(self, name, fileobj, *, tarinfo=None, **attrs):
        if not tarinfo:
            tarinfo = tarfile.TarInfo()
            tarinfo.mtime = self.mtime  # Default value
        name = fsdecode(name)
        tarinfo.name = "{}/{}".format(self.pkgname, name)
        for (key, value) in attrs.items():
            setattr(tarinfo, key, value)
        self.tar.addfile(tarinfo, fileobj)
    
    def addosfile(self, name, target=None):
        if not target:
            target = name
        with open(name, "rb", buffering=0) as file:
            # Explicit dummy name to avoid using file name of bytes
            tarinfo = self.tar.gettarinfo(fileobj=file, arcname="")
            self.addfile(target, file, tarinfo=tarinfo,
                uid=0, uname="", gid=0, gname="")

def parseaurinfo(aurinfo):
    parsed = dict((field, list()) for field in ARRAY_FIELDS)
    for line in aurinfo.splitlines():
        (name, value) = line.split(b" = ", 1)
        name = name.decode("ascii", "replace")
        if name in SINGLE_FIELDS + ("pkgver", "pkgbase"):
            parsed.setdefault(name, value)
        if name in ARRAY_FIELDS:
            parsed[name].append(value)
    return parsed

def getaurinfo(pkgbuild):
    script = StringIO()
    script.write(r"""\
        set -o errexit -o nounset
        . "$1"
    """)
    line = r"""${{{pacman}+printf '{aur} = %s\n' "${{{pacman}[@]}}"}}"""
    for name in SINGLE_FIELDS + ARRAY_FIELDS:
        print(line.format(pacman=name, aur=name), file=script)
    print(r"""${pkgver+printf 'pkgver = %s\n'
        "${epoch+$epoch:}$pkgver${pkgrel+-$pkgrel}"}""", file=script)
    
    # AUR < 3 looks for singular "depend" field names
    print(line.format(pacman="depends", aur="depend"), file=script)
    
    # AUR 3.2.0 gives the infamous "only lowercase letters are allowed" error
    # if the "pkgbase" entry is omitted
    script.write(r"""\
        if test -n "${pkgbase+set}" -o -n "${pkgname+set}"; then
            printf "pkgbase = %s\n" "${pkgbase-${pkgname[0]}}"
        fi
    """)
    
    script = script.getvalue()
    proc = ("bash", "-c", script, "--", pkgbuild)
    return subprocess.Popen(proc, stdin=subprocess.DEVNULL,
        stdout=subprocess.PIPE)

FILE_FIELDS = ("install", "changelog")  # Used internally, but not by AUR
SINGLE_FIELDS = (
    "pkgname", "epoch", "pkgrel", "pkgdesc", "url", "license") + FILE_FIELDS
ARRAY_FIELDS = ("depends", "source")

class SubprocessWriter(BufferedIOBase):
    def __init__(self, *pos, stdout_writer, **kw):
        self.pos = pos
        self.kw = kw
        self.out_writer = stdout_writer
    
    @contextmanager
    def context(self):
        with subprocess.Popen(*self.pos,
        stdin=subprocess.PIPE, stdout=subprocess.PIPE, bufsize=0,
        **self.kw) as proc, \
        selectors.DefaultSelector() as self.selector:
            self.selector.register(proc.stdout, selectors.EVENT_READ,
                self.read_output)
            self.selector.register(proc.stdin, selectors.EVENT_WRITE,
                self.write_input)
            yield
            self.selector.unregister(proc.stdin)
            proc.stdin.close()
            while self.selector.get_map():
                for [key, _] in self.selector.select():
                    key.data(key.fileobj)
        if proc.returncode:
            raise SystemExit(proc.returncode)
    
    def write(self, b):
        self.b = memoryview(b)
        while self.b:
            for [key, _] in self.selector.select():
                key.data(key.fileobj)
    
    def write_input(self, pipe):
        # TODO: use non-blocking writes to avoid unnecessary chunking
        done = pipe.write(self.b[:PIPE_BUF])
        self.b = self.b[done:]
    
    def read_output(self, pipe):
        data = pipe.read(0x10000)
        if not data:
            self.selector.unregister(pipe)
            return
        self.out_writer.write(data)

class TeeWriter(BufferedIOBase):
    def __init__(self, *outputs):
        self.outputs = outputs
    def write(self, b):
        for output in self.outputs:
            output.write(b)

if __name__ == "__main__":
    main()
